import { existsSync, promises as fsp } from "node:fs"
import { dirname, resolve as pathResolve } from "node:path"
import type { loadFile } from "magicast"
import { generateCode } from "magicast"
import { transform } from "esbuild"

export const NUXT_PE_HEADER = "x-nuxt-progressive-enhancement" as const
export const NITRO_LOADER_PREFIX = "_nitro/loader" as const

const GENERATED_TEXT = "/** This file is auto-generated by the form-actions module. /!\\ Do not modify it manually ! */ \n"

export async function writeLoader(file: Awaited<ReturnType<typeof loadFile<any>>>, loaderDirectoryPath = "", actionRoute = "") {
  file.exports.default = file.exports.loader
  delete file.exports.loader
  // If we have relative imports, we add one level of nesting
  for (const [key, imp] of Object.entries(file.imports)) {
    if (imp.from.startsWith("../")) {
      file.imports[key].from = `../${imp.from}`
    }
  }
  const { code } = generateCode(file) // We extract it with magicast...
  const shaked = await transform(code, { treeShaking: true, loader: "ts" }) // ...we clean it with esbuild ...
  const handler = `${loaderDirectoryPath}/${actionRoute}.get.ts`
  if (!existsSync(dirname(handler))) await fsp.mkdir(dirname(handler), { recursive: true })
  await fsp.writeFile(handler, GENERATED_TEXT)
  await fsp.appendFile(handler, shaked.code) // ...and we write it to the loader directory @todo Use virtualfiles ?
  return handler
}

export async function* walkFiles(dir: string): AsyncGenerator<string> {
  const entries = await fsp.readdir(dir, { withFileTypes: true })
  for (const entry of entries) {
    const res = pathResolve(dir, entry.name)
    if (entry.isDirectory()) {
      yield * walkFiles(res)
    }
    else {
      yield res
    }
  }
}

export function getActionRoute(actionPath: string) {
  const actionRegex = /actions\/(.*?)\.ts/
  const actionRoute = actionRegex.exec(actionPath)?.[1]
  if (!actionRoute) throw new Error(`Could not parse action route from ${actionPath}`)
  return actionRoute
}

export const addLoaderPrefix = (route: string) => `/${NITRO_LOADER_PREFIX}/${route}`

export function getLoaderRoute(path: string) {
  const regex = /\/server\/\.generated\/\.loader\/(.*?)\.get\.ts/
  const loaderRoute = regex.exec(path)?.[1]
  if (!loaderRoute) throw new Error(`Could not parse loader route from ${path}`)
  return addLoaderPrefix(loaderRoute)
}

/** Template Strings */

export const loaderTypesBefore = /* typescript */`
import type { EventHandler } from "h3"
import type { Ref, WatchSource } from "vue"

export type MultiWatchSources = (WatchSource<unknown> | object)[]

type ExtractLoader<Type> = Type extends EventHandler<infer X> ? X : never;` as const

export const loaderTypesAfter = /* typescript */`
interface AsyncDataExecuteOptions {
    _initial?: boolean
    dedupe?: boolean
  }
  
type FetchResult<T> = {
  result: Ref<T>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  pending: Ref<boolean>
  error: Ref<FetchError | null>
}
    
export type FetchNuxtLoaderFunction<T extends LoaderName> = (url: T, watch?: MultiWatchSources) => Promise<FetchResult<Loaders[T]>>` as const
