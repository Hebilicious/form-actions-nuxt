export const NITRO_LOADER_PREFIX = "_@loader_" as const

export const GENERATED_TEXT = "/** This file is auto-generated by the form-actions module. /!\\ Do not modify it manually ! */ \n"

export function getActionRoute(actionPath: string) {
  const actionRegex = /.*actions[\/\\](.*?)\.ts/;
  const actionRoute = actionRegex.exec(actionPath)?.[1]
  if (!actionRoute) throw new Error(`Could not parse action route from ${actionPath}`)
  return actionRoute
}

export const addLoaderPrefix = (route: string) => `/${NITRO_LOADER_PREFIX}/${route}`

export function getLoaderRoute(path: string) {
  const regex = /server[\/\\]\.generated[\/\\]\.loader[\/\\](.*?)\.get\.ts/
  const loaderRoute = regex.exec(path)?.[1]
  if (!loaderRoute) throw new Error(`Could not parse loader route from ${path}`)
  return addLoaderPrefix(loaderRoute)
}

/** Template Strings */

export const loaderTypesBefore = /* typescript */`
import type { EventHandler } from "h3"
import type { Ref, WatchSource } from "vue"
import type { FetchError, SearchParameters } from "ofetch"

type MultiWatchSources = (WatchSource<unknown> | object)[]

export type LoaderOptions = {
  watch?: MultiWatchSources
  params?: SearchParameters
}

type ExtractLoader<T> = ReturnType<T> extends Promise<infer U> ? U : never;` as const

export const loaderTypesAfter = /* typescript */`
interface AsyncDataExecuteOptions {
    _initial?: boolean
    dedupe?: boolean
  }

type FetchResult<T> = {
  result: Ref<T>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  pending: Ref<boolean>
  error: Ref<FetchError | null>
}

export type FetchNuxtLoaderFunction<T extends LoaderName> = (url: T, loaderOptions?: LoaderOptions) => Promise<FetchResult<Loaders[T]>>` as const
